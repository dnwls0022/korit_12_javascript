## 조건문
if else
switch
switch는 조건문과 달리 비교연산을 통한 t/f 를 뽑아내는 식이 switch와 소괄호내에 들어가지않는다.
```js
switch(변수){
  case 값1:
    실행문
    break;
  case 값2:
    실행문
    break;
  case 값3:
    실행문
    break;
    default;
    실행문default;
    (break;)
}
```

-if문과 switch문의 차이
if문은 조건식 내에 비교 연산을 사용할수있기 때문에 switch문 봐다 더 자주 사용된다. 하지만 if문의 경우 조건식을 위에서부터 차례대로 순차비교를 하기 때문에 속도가 느려진다...
비교연산이 필요없고 조건을 비교할 대상이 범위가 아니라 특정값인 경우엔 switch가 더 선호된다.

ch03_loops
-종류 
1. for
2. for-in
3. for-of
4. while
## for-loop
01_for_loop.js
### for-in (loop)
-향상된 for문
- java에선 향상된 for문을 사용할경우 인덱스넘버가없는 애들도출력가능
- js에서도 인덱스가없는 자료형의 element를 추출할때 for-in반복문을 사용한다
- javascript의 객체value를 추출할수있다.

### for-of (loop)
근데 얘도 향상된 for문입니다.
03_for_of.js
## 함수
-다양한 작업을 하나의 단위로 묶어놓은 코드블록
## 함수의 정의 및 사용
1. 함수 선언식
``` js
function 함수명(매개변수1,매개변수2){
  실행문;
  return이 optional
}
function add(a,b){
  let sum = a+b;
  return sum;
}
```
2. 함수의호출
```js
add (1,2); //근데 아무런 콘솔상에서 결과값이없었음 

console.log(sumNum)

```
3. 함수표현식
- 변수에 함수를 할당해서 사용하는 방식
메서드의 결과값이 변수에 들어가는게아닌 함수자체가들어간다.
- 형식
```js
선언자 변수명 = 함수명(매개변수1, 매개변수2){
  실행문
  return값
}
let sum= function(a,b){
  return a+b;
}


```
```js
let sum00 = sum(10, 5);   // 함수를 변수에 저장하니까 순서를 지키게 되어 오류가 발생
console.log(sum00);


// 함수 표현식 정의
let sum = function(a, b) {
  return a + b;
}
// 함수 호출
sum1 = sum(1, 2);
console.log(sum1);
sum2 = sum(3, 4);
console.log(sum2);


```
함수 및 함수 표현식의 경우 차이가 없어 보이지만 실행 측면 상에서의 차이가 존재합니다. 일반적인 함수 선언의 경우에는 정의 영역이 호출 영역보다 뒤에 있다고 하더라도 정상 작동을 합니다.

이는 js해석 엔진이 일반적으로 선언된 함수의 경우 먼저읽어들이기 때문에 호출구문이 선행하더라도 문제가없다

그런데 변수에 함수를 할당하는 함수 표현식의 경우 let선언자로 인해 선언된 순서를 읽기 때문에 정의가 먼저 되어야지만 호출이정상으로된다

4. Funtion생성자 함수
```js

let sum = new Funtion ('a', 'b', 'return a+b;');
let sum1 = sum(1,2);
let sum2 = sum(3,4);

```
# 함수사용이유
- 특정 기능을 하는 코드블록을 작성하면 해당 함수가 갖는 기능이 필요할때마다 호출마나면되기때문에 효율성이높다 같은 코드를 재작성할 필요가없기 때문에 장점이있고 기능변경이 일어날 때 전체 코그들 수정하는게아닌 특정함수 내부의 로직만수정하면 호출부분은 자동으로 수정사항이 반영된다.

1. 코드재사용성높다
2. 코드 유지보수 높다
3. 함수이름이 직관적인 경우 코드가독성이높다

# javascript내장객체
- 내장 객체가 가지고 있는 다양한 함수(메서드)의 기능을 파악하고 있을 때, 이를 조합하여 사용자 정의 함수 및 메서드를 정의하게 되면 가독성이 높은 코드를 작성할 수 있습니다.
# object객체
내장 객체는 브라우저의 js엔진에 내장된 객체를 의미하는데 object객체는 모든 
js의 루트객체에 해당한다 js에는 string/number/date/array/math등 다양한객체존재

```js
// 빈 객체생성
let person = new Object();
// 맴버설정
person.fname = '영';
person.lname = '김';
person.age = 20;
person.getFullName = funtion(){
  return this.lName+ ''+this.fName;
}
console.log(person.getFullName());  //결과 :김 영
```
코드에서 person이라는 객체의 property는 fname/ lname/ age / getfullname이란 key를 가지고있고 value로 각각 string string number 함수가담겨져있다 그러며녀 person객체에 있는 getfullname()은 함수니까 method라고한다.

# string객체
1. length - 문자열길이반환
2. indexof() - 문자열내에 
 특정 문자열이 존재하는지를 찾고, 있드면 문자열이 시작되는 index를 return합니다. 없으면 -1을 return합니다. ch05_builtin_objects -> 01_builtin.js
3. lastIndexOf() -
4. slice() -

# number객체
1. toString()
2. toExporential()  숫자를 지수형으로 반환해주는데 과학및공학에서 자주쓰인다.
3. toFixed() 소수점 몇쨰자리까지 보여줄지 결정한다 지정된 소수점 자리 수 아래에서 반올림
4. toPrecission()- 정수와 소수를 포함해서 몇 번째자리까지 보여줄지를 결정함.

```js
let x = 10.656;
x. toPrecission(); 10.656 
x. toPrecission();  11
x. toPrecission();  10.66

```
5. parseInt() 함수로서 int형태로 반환하기 때문에 실수를 정수형태로 혹은 문자열로 정수형태로 반환한다.

```js
parseInt('-10') // -10
parseInt('-12.33') //-12
parseInt('10') //10
parseInt('12.33') //12 
parseInt('10 20 30 ') //10 
parseInt('10 years ')  //10
parseInt('years 10 ') // NaN (Not a Number)
 
 ```
 6.parseFloat()
 ```js
 parseFloat('10') //10
 parseFloat('12.33') // 12.33
 parseFloat('10 years old') //10
 parseFloat('years 10') // NaN

 ```
 7. Number 객체의 property
 - MAX_VALUE - JS에서 다룰수있는 최대 수
 - MIN_VALUE - JS에서 다룰수있는 최소 수
 - POSITIVE-INFINITY - Infinity 
 - NEGATIVE_INFINITY - infinity
 - NaN - Not A Number
 
## Array객체
 1. toString()
 2. join() - 배열안의 모든 문자를 argument상에있는 문자를 사용하여 결합함
 3. pop() - 배열에서 마지막 데이터를 제거하고 마지막 데이터를 리턴함
 4. push() - 배열에서 새로운 element를 더하는 메서드
 5. shift()
 *스택과 큐는 자료구조 유형 중에 가장 많이쓰이는것들 두가지로 이 중 큐는 들어온 순서대로 쌓이고 출력 시에 첫 번째 데이터부터 출력한다 이 큐를 선입선출이라고한다
 * 배열은 데이터가 순서대로 지정되기 때문에 큐 자료구조를 구현할때 shift()
 메서드와 함께 사용하면 배열의 가장 첫 번째 데이터부터 차례대로 뽑을수있기 때문에 fifo를 구현하기가장좋다
 6. unshift()- 배열의 맨 앞에 element를 추가하고 배열 길이를 return
 7. 배열의 element변경
 ```js
 let fruits =  [1,2,3];
 fruits[0]=0;
 console.log(fruits); //결과 0,2,3
 ```
 8. splice() - 새로운 element를 특정위치에 추가하는 메서드 .추가 시에는 기존element를 삭제할수도있다.
 ```js
 let fruits = ['banana', 'orange', 'apple', 'mango'];
 fruits.splice(2,0, 'lemon', 'kiwi');
 console.log(fruits); //걀과 : [바나나, 오렌지, 레몬,키위, 애플,망고]
 ```
  splice(p1,p2,p3...)
 p1 - 새로운element를 추가할 인덱스 넘버 -즉 2번지에 추가하겠다.
 p2 - 인덱스 넘버에서 요소를 추가하기 전에 삭제할 요소 수 - 0이니삭제x
 p3 ..pn.. - 추가할 element들 (복수가능)
 9. concat() - 두개이상의배열을 하나로 결합
 ```js
 let names1 = ['김영', '김일'];
 let names2 = ['김이', '김사'];
 let names3 = ['김오', '김육'];
 let newNames = names1.concat(names2, names3);
 ```
 10. slice(p1,p2) slice(시작값,한계값)
 11. sort() -문자형 데이터가있는 경우 오름차순으로 정리
 -내림차순 정렬 배열명.reverse()
 12. filter() - 배열에서 특정 조건을 만족하는 뱌열의 element만 찾아서 _새로운 배열_ 로 return
 - 배열을 다룰때 가장 많이 사용하게되는 내장 함수 중하나로 특정 조건을 만족하는 데이터만 추출하는 프로그램을 작성할 때가 있는데 이때사용
 - 형식
 ```js
배열명.filter(콜백함수(element[, index[, arr]])[, thisArgs])
  - element - 처리할 현재 element에 해당합니다(numbers 그 안의 0 번지인 number)
  - index(optional) - 처리할 현재 element의 index 넘버
  - arr - 배열 전체

```

- collback함수 - 배열의 내부 element를 하나하나에 적용되는 별개의함수. filter()와 합쳐지게 했을 경우 특정 조건을 만족한 것들은 리턴이고 만족하지못한것들은 버려지는 로직이작성된다.
```js
let persons = [
  {
    name: '김영',
    point: 78,
    city: '서울',
  },
  {
    name: '김일',
    point: 98,
    city: '서울',
  },
  {
    name: '김이',
    point: 76,
    city: '제주',
  },
  {
    name: '김삼',
    point: 81,
    city: '부산',
  },
];

let personResult = persons.filter(function(person) {
  return person.point > 80;
})
console.log(personResult);
```

 ```js
1. let result = words.filter(function(word) {
  return word.length > 6;
} )
2. let personResult = persons.filter(function(person) {
  return person.point > 80;
})
```

 
 
 13. map() - 베열 데이터가 object형일 때 배열에 담긴 object를 새로윤 object로 변환한 다음 새로운 배열로 return한다.
 ```js
 let userlist = [
  {
    fName: '영',
    lName: '김',
    email: '@naver1',
  },
  {
    fName: '일',
    lName: '김',
    email: '@naver2',
  },
  {
    fName: '이',
    lName: '김',
    email: '@naver3',
  },
  {
    fName: '삼',
    lName: '김',
    email: '@naver4',
  },
  {
    fName: '사',
    lName: '김',
    email: '@naver5',
  },

];

let modifiedUserList =  userlist.map(function(user){
  return{
    fullName: user.lName+user.fName,
    lName:user.lName,
    fName:user.fName,
    email:user.email,
  };
})
console.log(modifiedUserList);
console.log(userlist);
 
 ```
## json객체
- 데이터를 저장하거나 전송할때 많이 사용되는 data교환형식이다.
- 특징
1. 서버와 클라이언트간데이터전송시많이사용
2. js의 object표기법과 매우 유사하다.
3. json데이터는 js의 json객체의.person을 이용하면 js객체로 변환해서 사용가능
4. 프로그래밍 언어 독립적
5. 대부분 언어에서 json데이터를 처리할 수 있는 라이브러리를 제공
```js
let data = {
  "employees" : [
    {'fname' : '영', 'iname ' : '김'},
    {'fname' : '영', 'iname ' : '김'},
    {'fname' : '영', 'iname ' : '김'}
  ]
}
//
console.log(data.employees[2].iname +data.employees[2].fname);

console.log(data);

let stringValue = JSON.stringify(data);
console.log(stringValue);

let text = '{"employees":[{"fname":"zero","iname ":"김"},{"fname":"영","iname ":"김"},{"fname":"영","iname ":"김"}]}';

let jsObj = JSON.parse(text);
console.log(jsObj);

/*
JS Object <->JSON으로 왔다갔다 하는 부분은 매우 자주일어난다.
JSON.parse(JSONString); 과 JSON.stringify(JSObject);항상 사용...
*/
```
- JSON.stringify() : 데이터를 서버로 전송하기위해ㅔ서 데이터를 문자열로 변환하기위해 메서드를 사용한다.
- JSON.parse() : 문자열을 argument로 하여 js객체로 변환하여줌.

## window객체
 - window는 전역객체라서 
    1. alert("이것은 alert입니다.");
    2. confirm("정말삭제?");
    3. prompt("비밀번호를 입력하세요");
    4. open("https://www.naver.com/");
    5. setTimeout()은 두번째 argument로 지정한 시간 간격 이후 첫 번째 argument에 정의한 
```html
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=
  , initial-scale=1.0">
  <title>Document</title>
</head>
<body bgcolor="5f5f5f">
  <script>
    /*window는 전역객체라서 
    alert("이것은 alert입니다.");
    confirm("정말삭제?");
    prompt("비밀번호를 입력하세요");
    open("https://www.naver.com/");
    */
  let myExec;
  function myFunction(){
    myExec = setTimeout(function(){console.log("5초후 프로그램실행")} ,5000 );
  }
  myFunction()
  </script>
  
</body>
</html>
```

cleartimeout() : setTimeout에서 정의한 콜백함수가 실행되지않았다면 함수 실행 중지를 clearTimeout()을 통해서 함수실행을 중지시킬수있다.
